# csa_lab3

 - Маликов Глеб Игоревич, P3224
 - Вариант: `asm | acc | neum | hw | tick | struct | trap | mem | cstr | prob2`
 - Базовый вариант

## Язык программирования

### Синтаксис

#### Форма Бэкуса-Наура

```
<программа> ::=
    "section .data" <перенос строки> {<данные> | <индекс>}
    "section .code" <перенос строки> {<инструкция> | <метка> | <индекс>}
    
<данные> ::= <метка переменной> ":" <переменная> [комментарий] <перенос строки>
<инструкция> ::= <адресная команда> <операнд> [комментарий] <перенос строки> | <безадресная команда> [комментарий] <перенос строки>
<метка> ::= <идентификатор> ":" [комментарий] <перенос строки>
<индекс> ::= "index" <число> [комментарий] <перенос строки>

<метка переменной> ::= <слово>
<переменная> ::= <число> | "'"<слово>"'"

<адресная команда> ::= "LOAD" | "SAVE" | "PUSH" | "POP" | "ADD" | "SUB" | "CMP" | "JMP" | "JMN" | "JMNN" | "JMZ" | "JMZN" | "JMC" | "JMNC"
<безадресная команда> ::= "INC" | "DEC" | "SHL" | "SHR" | "CLR" | "HLT" | "IRET" | "NOP"
<операнд> ::= <число> | <метка переменной> | "$" <метка переменной>

<идентификатор> ::= "_"<слово>
<комментарий> ::= ";" {<слово> | <число>}

<перенос строки> ::= "\n"
<слово> ::= <буква> {<буква>}
<число> ::= ["-"]<цифра> {<цифра>}
<буква> ::= a | b | c | ... | z | A | B | C | ... | Z
<цифра> ::= 0 | 1 | 2 | .. | 8 | 9
```

#### Объяснение

Вся программа описывается в виде двух секций: `.data` и `.code`.
 - В секции `.data` описываются переменные, которые могут использоваться в секции `.code`.
 - В секции `.code` описываются инструкции, которые выполняются процессором.

Каждая непустая строка программы это одно из нижеперечисленных:
 - Переменная: 
   - Может быть числом или строкой.
   - Строка заключается в одинарные кавычки.
 - Инструкция:
   - Состоит из команды и в случае адресной команды - операнда.
   - Команда может быть адресной или безадресной.
   - Операнд может быть число, метка переменной или метка инструкции.
   - Команда должна быть записана в верхнем регистре.
 - Метка:
   - Используется для обозначения места в коде, к которому можно выполнить переход.
 - Индекс:
   - Используется для обозначения ячейки памяти, в которую записываются последующие инструкции и данные.
 - Адрес:
   - Указывается название переменной
   - Если требуется ввод или вывод с устройства, то можно использовать параметры `IN`, `OUT`
   - Может указываться название переменной с префиксом `$` для косвенной адресации

#### Пример

Пример программы, вычисляющей С = A + B:

```asm
section .data
index 0
A: 5
B: 3
C: 0

section .code
index 100
_start
    LOAD A
    ADD B
    SAVE C
    HLT
```

### Семантика

- Видимость данных -- глобальная
- Поддерживаются целочисленные литералы, находящиеся в диапазоне от $`-2^{31}`$ до $`2^{31}-1`$
- Поддерживаются строковые литералы, символы стоки необходимо заключить в одинарные кавычки, перед строкой необходимо указать длину
- Код выполняется последовательно
- Программа обязательно должна включать метку `_start`, указывающую на 1-ю выполняемую интсрукцию.
- Название метки не должно совпадать с названием команды и не может начинаться с цифры.
- Переменные и метки не могут повторяться
- Переменные должны быть объявлены только в секции `.data`
- Метки должны быть объявлены только в секции `.code` и должны начинаться с символа `_`
- Все числа в программе должны быть записаны в десятичной системе счисления
- Метки должны быть объявлены до их использования
- Пустые строки игнорируются, количество пробелов в начале и конце строки не влияет на работу программы.
- Любой текст, расположенный в конце строки после символа `;` трактуется как комментарий.

Память выделяется статически, при запуске модели.


## Организация памяти

 - Память команд и данныx -- общая 
 - Размер машинного слова -- `32` бит 
 - Память содержит `2^11` ячеек
 - TODO

## Система команд

Особенности процессора:

- Машинное слово -- `32` бита, знаковое.
- В качестве аргументов команды принимают `11` битные беззнаковые адреса ячеек памяти.

Работа каждой ниструкции выполняется в нескольких тактах:
 - Чтение команды из памяти:
   - Счетчик команд (IP) указывает на адрес в памяти, откуда следует выбрать команду. Значение из этого адреса загружается в регистр команд (CR).
   - `IP -> AR, IP + 1 -> IP, mem[AR] -> DR, DR -> CR` 
 - Чтение операндов из памяти (если требуется):
   - Адрес операнда из регистра команд (CR) загружается в регистр данных (DR), который затем передается в регистр адреса (AR). Значение из этого адреса в памяти загружается обратно в регистр данных (DR).
   - `CR[addr] -> DR, DR -> AR, mem[AR] -> DR`
 - Выполнение операции:
   - Производятся действия необходимые для выполнения команды. Результат сохраняется в аккумуляторе (AC).
   - `ALU(CR, DR, AC) -> AC`
 - Проверка прерываний:
   - Если установлен флаг прерывания, то происходит переход к обработке прерывания.


### Набор команд

| Команда | Адресная | Ветвление | Количество тактов | Описание                                                               |
|:--------|:---------|-----------|:------------------|:-----------------------------------------------------------------------|
| LOAD    | +        | -         | 3                 | Загрузить значение из заданной ячейки в аккумулятор                    |
| SAVE    | +        | -         | 3                 | Записать значение из аккумулятора в заданную ячейку                    |
| PUSH    | +        | -         | 3                 | Положить значение из аккумулятора на стек                              |
| POP     | +        | -         | 3                 | Вытащить значение из стека в аккумулятор                               |
| INC     | -        | -         | 2                 | Прибавить 1 к значению в аккумуляторе                                  |
| DEC     | -        | -         | 2                 | Вычесть 1 из значения в аккумуляторе                                   |
| ADD     | +        | -         | 3                 | Сложить значение из ячейки с аккумулятором                             |
| SUB     | +        | -         | 3                 | Вычесть значение ячейки из аккумулятора                                |
| CMP     | +        | -         | 3                 | Сравнить значение аккумулятора с значением из ячейки                   |
| JMP     | +        | -         | 3                 | Перейти к заданной ячейке                                              |
| SHL     | -        | -         | 2                 | Сдвинуть значение в аккумуляторе влево, AC[15] -> C                    |
| SHR     | -        | -         | 2                 | Сдвинуть значение в аккумуляторе вправо, AC[0] -> C                    |
| JMN     | +        | +         | 3                 | Перейти в заданную ячейку если значение в аккумуляторе отрицательное   |
| JMNN    | +        | +         | 3                 | Перейти в заданную ячейку если значение в аккумуляторе неотрицательное |
| JMZ     | +        | +         | 3                 | Перейти в заданную ячейку если значение в аккумуляторе равно нулю      |
| JMZN    | +        | +         | 3                 | Перейти в заданную ячейку если значение в аккумуляторе не равно нулю   |
| JMC     | +        | +         | 3                 | Перейти в заданную ячейку если установлен флаг переноса                |
| JMNC    | +        | +         | 3                 | Перейти в заданную ячейку если флаг переноса не установлен             |
| CLR     | -        | -         | 2                 | Очистить аккумулятор (записать в него 0)                               |
| HLT     | -        | -         | 2                 | Остановить работу программы                                            |
| IRET    | -        | -         | 2                 | Вернуться из прерывания                                                |
| NOP     | -        | -         | 1                 | Нет операции                                                           |

### Кодирование команд

 - Команды сериализуются в список JSON
 - Каждая команда представляется объектом с полями:
   - `index` - ячейка памяти
   - `opcode` - код операции
   - `value` - значение переменной или адреса
   - `relative` - указывает если команда использует относительный адрес.

Пример сериализации команд:

Исходный код:
```asm
section .data
loc: 30
asdf: 2
result: 0
index 30
A: 5

section .code
_start
    LOAD $loc
    ADD asdf
    SAVE result
    HLT
```
```json
[
{"start_address": 31 },
{"index": 0, "opcode": "no_operation", "value": 30},
{"index": 1, "opcode": "no_operation", "value": 2},
{"index": 2, "opcode": "no_operation", "value": 0},
{"index": 30, "opcode": "no_operation", "value": 5},
{"index": 31, "opcode": "load", "value": 0, "relative": true},
{"index": 32, "opcode": "add", "value": 1, "relative": false},
{"index": 33, "opcode": "save", "value": 2, "relative": false},
{"index": 34, "opcode": "halt", "value": 0}
]
```

где:
 - `index` - ячейка памяти
 - `opcode` - код операции. Для записи констант используется `NOP`
 - `value` - значение операнда. Для команд без операндов используется 0
 - `relative` - указывает если команда использует относительный адрес.

## Транслятор

Интерфейс командной строки: `translator.py <source_file> <target_file>`

Реализован в модуле [translator.py](./translator.py).

Этапы работы транслятора:
 - TODO



## Модель процессора

Интерфейс командной строки: `machine.py <code_file> <input_file>`

Реализован в модуле [machine.py](./machine.py).

### DataPath

Реализован в модуле [data_path.py](./src/machine/data_path.py).

TODO: Scheme



### ControlUnit
TODO


## Тестирование
TODO
